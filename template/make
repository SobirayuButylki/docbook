#!/usr/bin/env ruby


# ruby make filename.extension
#  e.g.  ruby make book.pdf                  # Create a PDF
#         ruby make book.xhtml               # Create an XHTML file
#         ruby make book.chm                  # Create a CHM help file
#         ruby make book.pdf novalidate  # skips validation


#=================== Set path to DOCBOOK files =======

root = ENV['SHORT_ATTENTION_SPAN_DOCBOOK_PATH'] || "<#ROOT_PATH#>"
puts "root is #{root}"
# =========== Classes ==================

# add lchop to string class via a monkey patch
class String
  
  # Remove the first character from the string.
  def lchop
    s = self.gsub(/^./, "")
  end
end

require 'fileutils'

# Base clase for rendering a book. Generally you'd have your own class that inherits from this
class Docbook
  
  @xsl_extension = ""
  @xsl_stylesheet = ""
  
  attr_accessor :root, :file, :validate
  attr_reader :windows
  
  # Init and cnfigure the class
  #  b = Book.new(:root => "/home/homer/docbook", :file=>"book", :validate => true)
  def initialize(args ={})
     self.root = args[:root]
     self.file = args[:file]
     self.validate = args[:validate]
     
     @windows = PLATFORM.downcase.include?("win32")
     
  end
  
  # Generates the xml xslt processor command.
  # Override this in your own models to specify another command.
  def xml_cmd
    hcp_temp = @windows ? self.root : self.root.lchop
    
    highlighter_config_path ="file:///#{hcp_temp}/xsl/highlighting/xslthl-config.xml"

    saxon_cp = "#{self.root}/jars/xercesImpl-2.7.1.jar;"
    saxon_cp <<"#{self.root}/xsl/extensions/saxon65.jar;"
    saxon_cp <<"#{self.root}/jars/saxon.jar;"
    saxon_cp <<"#{self.root}/jars/xslthl-2.0.1.jar"
    
    xml_parser_config = "-Djavax.xml.parsers.DocumentBuilderFactory=org.apache.xerces.jaxp.DocumentBuilderFactoryImpl" 
    xml_parser_config << " -Djavax.xml.parsers.SAXParserFactory=org.apache.xerces.jaxp.SAXParserFactoryImpl" 
    xml_parser_config << " -Dorg.apache.xerces.xni.parser.XMLParserConfiguration=org.apache.xerces.parsers.XIncludeParserConfiguration"
    xml_parser_config << " -Dxslthl.config=#{highlighter_config_path}"
    
    cmd = "java -Xss512K -Xmx256m -cp \"#{saxon_cp}\" #{xml_parser_config} com.icl.saxon.StyleSheet -o #{self.file}.#{@xsl_extension} #{self.file}.xml #{@xsl_stylesheet}"
    cmd.gsub!(";",":") unless @windows
    return cmd
    

    
  end

  # Checks to see if the doc is valid.
  def valid?
    success = true
    validator_cmd = "java -jar -Xss512K #{self.root}/jars/relames.jar http://www.docbook.org/xml/5.0/rng/docbookxi.rng #{self.file}.xml"
    if validate
      puts "Validating your document..."
      output = `#{validator_cmd}`
      sucess = ! output.include?("NOT valid")
    else
      puts "Skipping validation..."
    end
    success
  end
  
  # Render the book
  def render
    success = true
    if valid?
       
       # call before_render if defined.
       self.send("before_render") if self.respond_to?("before_render")
       output = `#{xml_cmd}`

       success = ! output.include?("Exception")

       if success # if successful then call the callbacks
          self.after_render if self.respond_to?("after_render")
       end
    end
    success
  end

end


# Class for making HTML outputs
class Html < Docbook

  
  def initialize(args ={})
    super
    @xsl_extension = "html"
    @xsl_stylesheet = "#{self.root}/xsl/xhtml/docbook.xsl"
  end
  
  def after_render
    puts "Done"
  end

end

# Interface for Apache FOP, for taking FO output created by the XML processor and converting it to various formats. This class
# should be extended to control the various formats.
class Fop < Docbook
    
    # initialize the object and set the extensions and output type. Defaults to PDF
    def initialize(args = {})
      super
      @xsl_extension = "fo"
      @output = 'pdf'
      @xsl_stylesheet = "xsl/pdf.xsl"
    end
    
    # build up the options for FOP
    def fop_options
      fop_cp      = "#{self.root}/fop/avalon-framework-4.2.0.jar;"
      fop_cp << "#{self.root}/jars/batik-all-1.7.jar;"
      fop_cp << "#{self.root}/jars/commons-io-1.3.1.jar;"
      fop_cp << "#{self.root}/jars/commons-logging-1.0.4.jar;"
      fop_cp << "#{self.root}/jars/fop-hyph.jar;"
      fop_cp << "#{self.root}/jars/fop.jar;"
      fop_cp << "#{self.root}/jars/serializer-2.7.0.jar;"
      fop_cp << "#{self.root}/jars/xalan-2.7.0.jar;"
      fop_cp << "#{self.root}/jars/xercesImpl-2.7.1.jar;"
      fop_cp << "#{self.root}/jars/xml-apis-1.3.04.jar;"
      fop_cp << "#{self.root}/jars/xmlgraphics-commons-1.3.1.jar;"
      fop_cp
    end
    
    # Create the command to launch FOP
    def fop_command  
      cmd = "java -cp #{fop_options} org.apache.fop.cli.Main -fo #{self.file}.fo -#{@output} #{self.file}.#{@output}"

      cmd.gsub!(";",":") unless @windows
      return cmd
    end
    
    def before_render
      xsl_path = PLATFORM.downcase.include?("win32") ? self.root : self.root.lchop
      
      fo_xml = %Q{<?xml version='1.0'?>

      <!-- DO NOT CHANGE THIS FILE. IT IS AUTOGENERATED BY THE SHORT-ATTENTION-SPAN-DOCBOOK CHAIN
      -->

      <xsl:stylesheet 
         xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"
         xmlns:fo="http://www.w3.org/1999/XSL/Format"
         xmlns:xslthl="http://xslthl.sf.net"
         xmlns:d="http://docbook.org/ns/docbook"
      >
        <!-- Import the original FO stylesheet -->
        <xsl:import href="file:///#{xsl_path}/xsl/fo/docbook.xsl"/>
        <xsl:import href="file:///#{xsl_path}/xsl/fo/highlight.xsl"/>
      </xsl:stylesheet>
      }
      File.open("xsl/fo.xml", "w") do |f|
        f << fo_xml
      end
    end
    
    # Callback to build the final file after the XML-FO rendering occurs
    def after_render
               puts "Building #{@output}"
              `#{self.fop_command}`
            
              puts "Cleaning up"
              FileUtils.rm "#{file}.fo"
    end
    
end

# Renders a PDF from a docbook file
class Pdf < Fop
  def initialize(args={})
    super
    @output = "pdf"
  end
end

# Renders a TXT file from a docbook file
class Txt < Fop
  def initialize(args={})
    super
    @output = "txt"
  end
end



# Renders an RTF file from a docbook file
class Rtf < Fop
  def initialize(args={})
    super
    @output = "rtf"
  end
end


# Class for making Microsoft HTML help docs
class Chm < Docbook

    def initialize(args = {})
      raise "Can't use this unless you're on Windows" unless @windows
      super
      @xsl_extension = "hhp"
      @xsl_stylesheet = "#{self.root}/xsl/htmlhelp/htmlhelp.xsl"
    end
    
    def after_render
      puts "Building the Help file"
      `#{self.root}/hhc.exe #{self.file}.hhp"`
      puts "Cleaning up"
      FileUtils.rm "*.hh*"
      FileUtils.rm "*.html"
    end
    
end

# =========== Actual script starts here ==============
# process the doc.


# parse command line
file_and_format = ARGV[0].split('.')
file = file_and_format[0]
format = file_and_format[1] || "pdf"

validate = ARGV[1] != "novalidate"


# decide what to do
case format
  when "pdf"
    book = Pdf.new(:root => root, :file => file, :validate => validate)
  when "xhtml"
    book = Html.new(:root => root, :file => file, :validate => validate)
  when "chm"
    book = Chm.new(:root => root, :file => file, :validate => validate)
  when 'rtf'
    book = Rtf.new(:root => root, :file => file, :validate => validate)
  when 'txt'
    book = Txt.new(:root => root, :file => file, :validate => validate)
    
end

if book.render
  "Done"
else
  "Book not rendered."
end